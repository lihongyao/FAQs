### 001：跨域问题 ✔️

由于浏览器 **同源策略** 的限制，非同源的请求会被限制。

1. jsonp
   - 利用 `<script>` 标签不受同源策略限制的特性，通过动态创建脚本实现跨域请求。
   - **特点**：仅支持 GET 请求，安全性较低。
2. 配置nginx反向代理
   - 通过配置 Nginx 将请求转发到目标服务器，避免浏览器直接跨域。
   - **特点**：灵活高效，适合生产环境。
3. 设置CORS（跨域资源共享）
   - 服务器设置响应头（如 `Access-Control-Allow-Origin`），允许指定来源的跨域请求。
   - **特点**：支持多种请求方法，安全性较高。
4. WebSocket
   - 使用 WebSocket 协议建立双向通信，**浏览器允许跨域发起 WebSocket 连接**
   - **特点**：适合实时通信场景，如聊天应用。

### 002：浏览器存储

1. Cookies
   - 用于存储小型数据，支持服务器端和客户端读写。
   - **特点**：可设置过期时间，每次请求自动携带，存储空间小（约 4KB）。

2. WebStorage
   - localStorage：持久化存储，数据不会随页面关闭而清除。
   - sessionStorage：会话级存储，数据在页面关闭后清除。
   - **特点**：存储空间较大（约 5MB），仅客户端读写。

3. IndexedDB
   - 浏览器提供的低级 API，支持存储大量结构化数据。
   - **特点**：异步操作，适合存储复杂数据，存储空间大（通常 50MB 以上）。

4. Cache Storage
   - 用于缓存网络请求和响应，支持 Service Worker 实现离线功能。
   - **特点**：适合 PWA 应用，存储空间较大。

### 003：简述一下浏览器渲染机制？✔️

1. 解析HTML，生成DOM树。
2. 解析CSS，生成CSSOM树。
3. 合并 DOM 和 CSSOM，生成渲染树。
4. 布局（回流）：计算元素的位置和大小。
5. 绘制（重绘）：将元素绘制到屏幕上。
6. 合成：将绘制结果合并，呈现最终页面。

浏览器通过解析、布局、绘制和合成，将 HTML 和 CSS 转换为用户可见的页面。

### 004：重排（回流）✔️

**重排（回流）** 是指当元素 **几何属性**（如位置、尺寸）发生变化时，浏览器需要重新计算布局，将元素放到正确位置的过程。

**触发条件：**

1. 添加或删除可见的 DOM 元素。
2. 元素尺寸变化（如宽度、高度、边距、填充、边框等）。

> 重排是浏览器重新计算布局的过程，影响性能，应尽量减少触发。

### 005：重绘 ✔️

**重绘** 是指当元素 **外观**（如颜色、背景、阴影等）发生变化，但布局未变时，浏览器重新绘制元素的过程。

**触发条件：**改变元素的 `color`、`background`、`box-shadow` 等样式属性。

> 重绘只影响外观，不改变布局，但频繁重绘仍会影响性能，需合理优化。

### 006：重排重绘优化建议 ✔️

- 减少重排：批量操作DOM（文档片段）和缓存布局属性
- 减少重绘：优先用 `transform/opacity`
- 动画用 `requestAnimationFrame`和硬件加速

### 007：在浏览器的事件循环中，若定时器回调（`setTimeout`）、用户点击事件回调（如 `click`）和后端接口响应回调（如 `fetch`的 `then`）在同一渲染周期内触发，他们的执行顺序是怎样的？

它们的执行顺序由 **任务类型优先级** 和 **队列调度规则** 共同决定。以下是具体分析：

微任务 > 交互事件（高优先级宏任务） > 普通宏任务（定时器、网络请求）

**可能的输出顺序**：

1. `接口响应`（微任务优先）
2. `点击事件`（交互队列优先级高于定时器）
3. `定时器`（普通宏任务）

**关键点**

1. 接口响应的 `then`回调作为微任务，必然在宏任务前执行。
2. 用户点击事件可能因浏览器优化（如 Chrome 的交互队列优先级）而早于定时器
3. 若定时器延迟更短（如 `setTimeout(fn, 0)`vs `setTimeout(fn, 10)`），短延迟的定时器可能先执行。

