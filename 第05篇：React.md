### 001：React 理念

从早期官网中可以看到，React 是用js构建 **快速响应** 的大型Web应用程序的首选方式。可见，关键是实现 **快速响应**。那么制约 **快速响应** 的因素是什么呢？

1. CPU的瓶颈

   解决方案：**时间切片**。

   在浏览器每一帧的时间中，预留一些时间给JS线程，`React` 利用这部分时间更新组件（源码中，预留的初始时间是5ms），当预留的时间不够用时，`React`将线程控制权交还给浏览器使其有时间渲染UI，`React`则等待下一帧时间到来继续被中断的工作。

   时间切片的关键是将**同步的更新**变为**可中断的异步更新**。

2. IO的瓶颈

   解决方案：**Suspense**

### 002：React 架构

架构可以分为三层：

- Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入**Reconciler** （React 16新增）
- Reconciler（协调器）—— 负责找出变化的组件（*为变化的虚拟DOM打上代表增/删/更新的标记*）
- Renderer（渲染器）—— 负责将变化的组件渲染到页面上（*根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作*）

### 003：Fiber（虚拟DOM）

Fiber 中文翻译叫做 纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。

在js中，协程的实现便是 `Generator`，我们可以将 纤程（Fiber）、协程（Generator）理解为 **代数效应** 思想在 js 中的体现。

Firber 可以理解为：React 内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。其中每个任务更新单元为 React Element 对应的 Firber节点。

### 004：React 组件通信方式

1. props & callback
2. context
3. redux / eventBus 

### 005：谈谈你对合成事件的理解？

React通过给document上挂载一个事件监听函数，通过 **事件冒泡** 的方式来完成事件的执行，当DOM元素触发后会冒泡到document，而React就会找到对应的组件生成一个合成事件出来，并按组件树模拟一遍事件冒泡，这就是React中的合成事件。

### 006：`setState` 及存在异步情况也存在同步情况

1. 异步情况：在React事件（*合成事件*）当中是异步操作
2. 同步情况：在定时器或者自定以DOM事件中，都是同步的。

### 007：React 生命周期

创建阶段：

- constructor
- render



