### 001：HTTP是什么？⭐️

1. HTTP是一种 **超文本传输协议**，是客户端和服务器端请求与应答的标准。
2. HTTP是一种 **应用层协议**，由请求和响应组成，是一个标准的客户端服务器模型。
3. HTTP是一种 **无状态协议**，每个请求与响应之间都是相互独立的，服务器默认情况下无法知道两个请求是否来自同一个客户端。
4. HTTP本质上来说就是一个 **通信规则**，规定了客户端发送给服务器以及服务器发送给客户端的内容格式。

### 002：HTTP和HTTPS的区别？⭐️

1. HTTP 是超文本传输协议，信息是明文传输，HTTPS 协议要比 HTTP 协议**安全**，HTTPS 是具有安全性的 SSL 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。
2. HTTP默认的端口号为 **80**，HTTPS的默认端口号为 **443**。
3. HTTPS 协议需要 CA 证书。
4. HTTPS 缓存不如 HTTP 高效，会增加数据开销。

### 003：TCP三次握手 ⭐️

1. 第一次握手（**SYN**）：建立连接时，客户端发送SYN包（*SYN=1,Seq=x*）到服务器 ，并进入 `SYN_SENT` 状态，等待服务器确认。

2. 第二次握手（**SYN + ACK**）：服务器收到SYN包并确认客户的SYN（*ACK=x+1*），同时发送一个自己的SYN包（*SYN=1,Seq=y*），即SYN + ACK包，此时服务器进入 `SYN_RCVD` 状态。

3. 第三次握手（**ACK**）：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（*ACK=y+1*），此时客户端和服务器进入 `ESTABLISHED`（TCP连接成功）状态，完成三次握手。

### 004：TCP四次挥手

### 005：如何确保数据包传输的可靠性？

TCP协议

- SYN：同步序列编号（确保有序）
- ACK：确认号（解决丢包问题）

### 006：TCP和UDP的区别？⭐️

TCP和UDP是两种常见的传输协议。

1. TCP是连接导向的，提供可靠的数据传输，适用于对数据完整性要求较高的场景。
2. UDP是无连接的，提供实时性较高的数据传输，适用于对时延要求较高、数据丢失可以容忍的场景。
3. TCP有序、可靠，UDP无序、不可靠。
4. TCP没有数据包大小限制，UDP受限于最大传输单元（MTU）的大小（64KB以下）

根据具体需求选择TCP或UDP，TCP适用于可靠性要求高的场景，UDP适用于实时性要求高且数据丢失可以容忍的场景（*音视频流传输/游戏通信/DNS解析/网络广播等*）。

### 007：Cookie 🆚 Session ⭐️

Cookie和Session都是用于跟踪浏览器用户身份的会话方式，他们的区别如下：

1. Cookie工作原理：服务器通过响应头中的 Set-Cookie 头部将 Cookie 信息发送给客户端，客户端将 Cookie 存储在本地。之后，每次请求时，客户端会将存储的 Cookie 通过请求头中的 Cookie 字段发送给服务器。
2. Session工作原理：当用户第一次访问服务器时，服务器会为该用户创建一个唯一的 Session ID，并将该 ID 存储在 Cookie 中发送给客户端。客户端每次请求时，会将 Session ID 通过 Cookie 发送给服务器，服务器根据 Session ID 来识别用户并维护相应的用户数据。

| #          | Cookie                                                     | HttpSession                                                  |
| ---------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 存储位置   | 客户端                                                     | 服务器端                                                     |
| 存储容量   | 单个Cookie保存的数据 <=4KB<br />一个站点最多保存20个Cookie | 没有上限<br />但出于对服务端的性能考虑，不要存放过多的东西<br />并且设置Session删除机制 |
| 安全性     | 对客户端是可见的，以明文保存（不安全）                     | 存储在服务器上，不存在敏感信息泄露的风险                     |
| 服务器压力 | 保存在客户端，不占用服务器资源                             | 保存在服务器端，每个用户产生一个Session，耗费大量内存        |
| 跨域支持   | 支持夸域名访问                                             | 不支持跨域名访问                                             |

### 008：HTTP/浏览器缓存机制 ⭐️⭐️

HTTP 缓存是指客户端和服务器之间在传输资源时，使用缓存来减少重复请求和提高性能的一组规则和策略。

浏览器在第一次请求发生后，再次请求时：

1. 浏览器会先获取该资源缓存的header信息，根据其中的Expires和Cahe-Control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；
2. 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match），由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。

HTTP缓存可以分为两种类型：

1. 强制缓存
   - 强制缓存是由服务器在响应头中设置的指令，用于告知客户端在一定时间内可以直接从缓存中获取资源而无需再次请求服务器。
   - 常用的强制缓存指令包括 Expires 和 Cache-Control 头部字段。
   - Expires 设置一个具体的过期时间，而 Cache-Control 通过 max-age 设置缓存的有效期（秒）。
   - 当客户端发起请求时，如果缓存尚未过期，则直接从缓存中获取资源，而不向服务器发送请求。

2. 协商缓存
   - 协商缓存是通过与服务器进行通信，验证缓存是否仍然有效的一种缓存机制。
   - 客户端在发起请求时，将上次响应中的一些验证信息（如 ETag 或 Last-Modified）发送给服务器。
   - 服务器使用这些验证信息来判断资源是否发生了变化。如果未发生变化，则返回 304 Not Modified 状态码，告知客户端可以从缓存中获取资源。
   - 常用的验证字段包括 If-None-Match 和 If-Modified-Since 头部字段。

### 009：HTTP状态码及其含义？⭐️

1. 1XX：信息状态码（*了解*）
2. 2XX：成功状态码
   - `200 ok` 请求成功
   - `201 Created` 请求成功并且服务器创建了新的资源
   - `202 Accepted` 服务器已接受请求，但尚未处理
3. 3XX：重定向相关
   - `301 Moved Permanently` 永久重定向
   - `302 Found` 临时性重定向
   - `303 See other` 临时重定向，且总是使用 GET 请求新的 URI
   - `304 Not Modified` 协商缓存，告知客户端可以从缓存中获取资源
4. 4XX：客户端错误
   - `400 Bad Request` 服务器⽆法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 
   - `401 Unauthorized` 请求未授
   - `403 Forbidden` 禁止访问
   - `404 Not Found` 资源不存在
5. 5XX：服务端错误
   - `500 Internal Server Error` 最常⻅的服务器端错误。 
   - `503 Service Unavailable` 服务器端暂时⽆法处理请求 ( 可能是过载或维护) 。 

> 重点掌握：301/302/304

### 010：HTTP请求方法及其用途 ⭐️

1. GET：获取资源
2. POST：提交数据或者附加新的数据
3. PUT：同POST，区别在于 PUT 指定了资源在服务器上的位置，而POST没有
4. HEAD：请求页面的首部
5. DELETE：删除资源
6. OPTIONS：获取当前URL所支持的方法，如果请求成功，会有一个Allow的头包含类似”GET，POST“这样的信息
7. TRACE：激发⼀个远程的，应用层的请求消息回路
8. CONNECT：把请求连接转换到透明的 TCP/IP 通道

### 011：从浏览器地址栏输入url到页面显示的步骤 ⭐️

相似问题：

1. 在浏览器里，从输入 URL 到页面展示，这中间发生了什么？
2. 浏览器导航流程？
3. 浏览器渲染页面的过程？

答题参考：

1. 浏览器首先判断输入的内容是URL还是关键字
   - 如果是关键字，则使用默认配置的搜索引擎来查询。
   - 如果是请求的URL，则进入下一步（*查看缓存*）。
2. 浏览器查看缓存，判断请求资源是否在缓存中（强缓存/协商缓存）
   - 存在，则校验新鲜度（*有效期*），如果足够新鲜，则提供给客户端，否则与服务器进行验证。
     - 检验新鲜：Expires（*http1.0*） / Cache-Control:max-age=值（*http1.1*）
   - 不存在：发起新的请求
3. 浏览器解析URL获取协议、主机、端口号、路径、查询参数、锚点等
4. 浏览器组装一个HTTP（GET）请求报文
5. 获取主机IP地址，过程是：浏览器缓存 → 本机缓存 → hosts文件 → 路由器缓存 → ISP DNS 缓存 → DNS递归查询（*可能存在负载均衡导致每次IP不一样*）
6. 建立TCP链接：三次握手（*参考面试题：003*）
7. TCP链接建立后，浏览器向服务器发送 HTTP 请求（*请求包括请求行、请求头和请求体*）。
8. 服务器处理请求：

   - 检查HTTP请求是否命中协商缓存，如果命中，则返回304状态码。校验缓存是否新鲜的相关字段：
     - Last-Modified/IF-Modified-Since
     - Etag/IF-None-Match

   - 处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作。
9. 服务器响应请求：将响应报文通过TCP连接发送回浏览器。
10. 浏览器接收响应，然后根据情况选择关闭TCP链接（*四次挥手*）还是保留重用。
11. 浏览器检查响应状态码：是否为1XX、3XX、4XX、5XX，这些情况的处理与2XX不同。
12. 判断是否是否可以缓存。
13. 对响应的数据进行解码（*例如gzip压缩*）。
14. 根据资源类型决定如何处理（*假设资源为HTML文档*）。
15. 解析HTML，构建DOM树。

    - 根据HTML规范将字符流解析为标记。
    - 词法分析将标记转换为对象并定义属性和规则。
    - 根据HTML标记关系将对象组成DOM树。
16. 解析过程中，如果遇到图片、样式表、js文件等资源则会启动下载，发起额外的网络请求。
17. 解析CSS，生成CSSOM树

    - 字符流转换为标记流。
    - 根据标记创建节点。
    - 节点创建CSSOM树。
18. 根据DOM树和CSSOM树构建渲染树。
19. 布局：渲染树构建完成后，浏览器进行布局过程，计算出每个元素在屏幕上的位置和大小。布局过程也称为回流或排版。
20. 绘制：布局完成后，浏览器将渲染树中的元素转换为屏幕上的实际像素，这个过程称为绘制。绘制使用图形库将元素转换为位图，并进行组合和渲染。
21. 显示页面（*HTML解析过程中会逐步显示页面*）

### 013：localStorage、sessionStorage、cookie 支持跨域么？⭐️

1. localStorage 和 sessionStorage 存储的数据是基于源策略的，不支持跨域。

2. Cookie 可以设置为跨域访问，但有一些限制。

   通过设置 `SameSite` 属性可以控制跨域访问的行为

   - `SameSite=None; 	1`：允许跨域（https）
   - `SameSite=Lax`：允许跨域（https），只有在顶级导航时才会发送 Cookie。
   - `SameSite=Strict`：禁止跨域
