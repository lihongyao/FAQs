### 001：简述什么是BFC？✔️

1. 基本概念：**B**lock **F**ormatting **C**ontext，块级格式化上下文，是 一块独立渲染区域，内部元素的布局不会影响外部元素。

2. 解决什么问题？

   - **清除浮动**（防止父元素高度塌陷）
   - **避免 margin 重叠**（相邻元素的 margin 不会合并）
   - **隔离布局**（内部元素不影响外部布局）

3. 满足以下条件，就可以创建BFC

   - `float: left/right`（非 `none`）
   - `position: absolute/fixed`
   - `display: inline-block / table-cell / flex / grid`
   - `overflow: hidden / auto / scroll`（非 `visible`）

**BFC 是一个独立布局空间，能解决浮动、margin 重叠等问题，通过 `float`、`position`、`display` 、`overflow` 等属性触发。**

### 002：px/em/rem ✔️

px、rem、em 都是表示长度或字体大小的单位，主要区别在于 **相对性** 和 **继承性**：

- `px`：固定单位，相对于 **显示器屏幕分辨率** 而言，值是固定的，指定多少就是多少。
- `em`：相对单位，相对于 **父元素** 字体大小，可被子元素继承。
  - em = 像素值 / 父元素字体大小
- `rem`：相对单位，相对于 **根元素** 字体大小，不会被子元素继承。
  - 根元素字体大小 = 设备宽度/设计稿宽度 * 100
  - rem = 设计稿值 / 100

### 003：谈一谈盒子模型

1. 组成：content - padding - border -margin
2. 标准盒子模型：box-sizing:content-box
3. IE盒子模型：box-sizing:border-box

### 004：CSS3有哪些新特性？

媒体查询/文本阴影/渐变/圆角/盒子阴影/过渡/动画/变形转换/弹性布局/网格布局/视口单位

### 005：link 与 @import 的区别？

`<link>`和`@import`都是用于在HTML或CSS中导入外部资源的方法，但它们有一些区别：

1. **用法和位置：**
   - `<link>`：`<link>`标签是HTML中的标签，用于在HTML文档中引入外部资源，如样式表、图标等。它通常位于`<head>`标签内，并使用`rel`属性指定资源的关系类型，如`stylesheet`表示样式表。
   - `@import`：`@import`是CSS中的规则，用于在CSS文件中导入外部样式表。它位于CSS文件的顶部，并在其他CSS规则之前使用。`@import`规则是以`@import`关键字开始的，并指定要导入的资源路径。
2. **加载行为：**
   - `<link>`：`<link>`标签在浏览器解析HTML文档时就会同时加载指定的资源，不会阻塞页面的渲染。它可以并行加载多个资源，提高加载效率。
   - `@import`：`@import`规则是在CSS文件加载时才会加载导入的资源。它会阻塞页面的渲染，直到该资源加载完成才会继续渲染。如果有多个`@import`规则，它们会按顺序加载。
3. **兼容性：**
   - `<link>`：`<link>`标签是HTML的一部分，几乎所有的浏览器都支持它。
   - `@import`：`@import`规则是CSS2引入的特性，它在一些旧版本的浏览器中可能不被完全支持。尤其在IE6-IE9中，对`@import`规则的支持存在一些限制。
4. **优先级：**
   - `<link>`：`<link>`标签中的样式表具有较高的优先级，可以覆盖其他样式规则。它们的加载顺序也会影响样式的优先级。
   - `@import`：`@import`规则的样式表优先级较低，它们会在其他样式规则之后加载，并且优先级较低的样式可能会被其他样式覆盖。

综上所述，`<link>`标签具有更广泛的兼容性，可以并行加载多个资源，并且在样式覆盖和优先级方面更灵活。相比之下，`@import`规则在加载行为和兼容性方面可能存在一些限制。因此，在实际开发中，优先选择使用`<link>`标签来引入外部样式表。

### 006：什么是外边距重叠？ ✔️

**定义**：相邻块级元素的垂直外边距会合并（重叠）的现象。

**重叠规则**：

1. 同号取大值（正正取最大，负负取最负）
2. 异号相加值（正负相加）

**典型场景**：

- 相邻兄弟元素
- 父元素与第一个/最后一个子元素（无边框/padding隔开时）
- 空块级元素（自身上下margin合并）

**面试技巧回答**

外边距重叠是指相邻块级元素的 **垂直边距** 会合并成一个边距。合并规则是：同号取绝对值大的，异号相加。常见于相邻元素、父子元素之间，可以通过创建BFC或添加边框/padding来避免。

### 007：`flex：0 1 auto` 是什么意思？✔️

`flex` 是 `flex-grow`、`flex-shrink`、`flex-basis` 的缩写：

- `flex-grow`：放大比例
  - 默认为0，表示如果存在剩余空间，也不放大，都为1时表示平均分配剩余空间；
- `flex-shrink`：缩小比例
  - 默认为1，即如果空间不足，该项目将等比缩小；
- `flex-basis`：用于设置项目占据的主轴空间（项目初始大小）
  - 默认为 auto，即项目大小由内容决定。
  - 设置为固定值表示项目占据的主轴大小等于固定值  。

> 延伸试题：
>
>  `flex:1` 是什么意思？
>
> `flex:1` 是 `flex-grow: 1`、`flex-shrink: 1`、`flex-basis: auto` 的缩写，表示元素会 **自动占据剩余空间**，并在空间不足时 **等比缩小**。

### 008：解释什么是浮动以及工作原理？

浮动是一种用于控制元素在页面布局中位置的属性。通过将元素浮动到文档流中的左侧或右侧，可以让其他元素环绕在其周围。

浮动的工作原理如下：

1. **浮动元素的定位：** 使用`float`属性可以将元素从正常的文档流中脱离出来，并移动到其容器的左侧或右侧。浮动元素会尽量向左或向右移动，直到碰到其容器的边缘或其他浮动元素。
2. **环绕效果：** 其他非浮动的元素会根据浮动元素的位置进行环绕布局。环绕效果使得文本和其他元素可以围绕在浮动元素的周围。

需要注意的是，浮动元素对父容器和其他兄弟元素的布局产生了一些影响：

- **父容器高度塌陷：** 当父容器中的所有子元素都是浮动元素时，父容器的高度将塌陷为0，因为浮动元素脱离了文档流，不会撑开父容器的高度。为了避免这种情况，可以在父容器上添加`overflow: auto`或`clearfix`来清除浮动。
- **兄弟元素的环绕布局：** 兄弟元素会围绕在浮动元素的周围进行布局。如果兄弟元素是块级元素，默认情况下会占据浮动元素旁边的空间，并向下移动。如果希望兄弟元素不环绕浮动元素，可以使用`clear`属性来清除浮动。

### 009：如何实现三栏布局

1. 绝对定位
2. 浮动
3. Flex → flex:1
4. Grid

### 010：如何实现元素居中？

1. 弹性盒模型；
2. 绝对定位 + margin:
3. 绝对定位 + 平移：transform：translate（-50%，-50%）;
4. line-height 和 height 保持一致（里面的元素必须是inline，否则不生效）；
5. 通过padding：（已知子元素宽高情况，但不推荐）； 

### 011：CSS选择器及其优先级

| 选择器         | 格式                   | 优先级权重 |
| -------------- | ---------------------- | ---------- |
| `id` 选择器    | `#id`                  | 100        |
| 类选择器       | `#classname`           | 10         |
| 属性选择器     | `input[type='button']` | 10         |
| 伪类选择器     | `li:last-child`        | 10         |
| 标签选择器     | `div`                  | 1          |
| 伪元素选择器   | `li:after`             | 1          |
| 相邻兄弟选择器 | `h1 + p`               | 0          |
| 子选择器       | `ul > li`              | 0          |
| 后代选择器     | `li a`                 | 0          |
| 通配符选择器   | `*`                    | 0          |

对于选择器的 **优先级**：

- 标签选择器、伪元素选择器：`1`

- 类选择器、伪类选择器、属性选择器：`10`
- `id` 选择器：`100`
- 内联样式：`1000`

**注意事项：**

- `!important` 声明的样式的优先级最高；
- 如果优先级相同，则最后出现的样式生效；
- 继承得到的样式的优先级最低；
- 通用选择器（`*`）、子选择器（`>`）和相邻同胞选择器（`+`）并不在这四个等级中，所以它们的权值都为 `0` ；
- 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。

### 012：CSS 中可继承与不可继承属性有哪些？

**（1）继承属性**

- <u>字体</u> 系列属性：`font-family`、`font-weight`、`font-size`、`font-style`
- <u>文本</u> 系列属性：`text-indent`、`text-align`、`line-height`、`word-spacing`、`letter-spacing`、`text-transform`、`color`
- 元素可见性：`visibility`
- 列表布局属性：`list-style-type`、`ist-style-image` 等
- 光标属性：`cursor`

**（2）非继承属性**

- `display`
- 文本属性：`vertical-align`、`text-decoration`、`text-shadow`、`white-space`
- 盒子模型相关属性
- 背景属性
- 定位属性
- 轮廓样式属性
- ...

### 013：隐藏元素的方法有哪些？✔️

| 方法                  | 占据空间 | 触发重排/重绘 | 事件响应 | 动画支持 | 无障碍访问 |
| --------------------- | -------- | ------------- | -------- | -------- | ---------- |
| `display: none`       | ❌        | 重排 + 重绘   | ❌        | ❌        | ❌          |
| `visibility: hidden`  | ✔️        | 仅重绘        | ❌        | ✔️        | ❌          |
| `opacity: 0`          | ✔️        | 无            | ✔️        | ✔️        | ✔️          |
| `position: absolute`  | ❌        | 重排          | ❌        | ✔️        | ✔️          |
| `transform: scale(0)` | ✔️        | 无            | ✔️        | ✔️        | ✔️          |
| `height: 0`           | ❌        | 重排          | ❌        | ✔️        | ❌          |

### 014：伪元素和伪类的区别和作用？

- **伪类**：给**已有元素**加特效（如:hover变色）
- **伪元素**：在**元素内外**插内容（如::before加小图标）

### 015：CSS 优化和提高性能的方法有哪些？✔️

1. 合并压缩 CSS 文件，减少 HTTP 请求
2. 使用属性简写（如 margin: 10px 0 代替分写属性）
3. 简化选择器，避免深层嵌套（如 .nav-link 代替 div#header ul.nav li a）
4. 减少冗余代码，利用 CSS 继承机制（如 font-family 继承）
5. 避免频繁重绘和回流，用 transform 和 opacity 做动画
6. 使用雪碧图（CSS Sprite）合并小图标，减少请求
7. 采用字体图标（如 iconfont）替代图片，提升加载性能
8. 启用浏览器缓存，设置 Cache-Control 缓存 CSS 文件
9. 使用 CSS 预处理器（如 Sass/Less），提升开发效率并自动压缩代码
10. 触发硬件加速，通过 transform: translateZ(0) 提升动画性能
11. 按需加载 CSS，动态加载当前页面所需样式（如 import）
12. 用 PostCSS 自动优化，如添加前缀、删除未使用样式（PurgeCSS）

### 016：如何判断元素是否到达可视区域？

以图片显示为例：

![](./IMGS/iQ_view_area.png)

- `window.innerHeight` 是浏览器可视区的高度；

- `document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动过的距离；
- `imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）；
- 内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`

### 017：如何解决 1px 问题？

1px问题是指在高像素密度（Retina）屏幕上显示的1像素边框或线条看起来过粗的问题。这是由于高像素密度屏幕的物理像素与CSS像素之间的差异导致的。

以下是一些常见的解决1px问题的方法：

1. **使用缩放：** 可以使用`transform: scale()`将元素进行缩放，使其显示为0.5px或0.3333px等细小像素。例如：

   ```css
   .element {
     transform: scale(0.5);
   }
   ```

2. **使用伪元素和transform：** 可以使用伪元素和`transform: scaleY()`来创建细小的边框或线条。例如：

   ```css
   .element::before {
     content: '';
     display: block;
     height: 1px;
     background-color: #000;
     transform: scaleY(0.5);
   }
   ```

3. **使用border-image：** 可以使用CSS的`border-image`属性来创建细小的边框。通过定义一个1像素的图片作为边框图像，并使用`slice`和`repeat`属性来控制边框的展示方式。例如：

   ```css
   .element {
     border-width: 1px;
     border-style: solid;
     border-image: url(border-image.png) 1 1 stretch;
   }
   ```

### 018：如何设置小于12px的字体？ ✔️

1. `zoom`：设置缩放比例
2. `transform:scale(xx)`

### 019：对 sticky 定位的理解？

`sticky` 是一种 **混合定位** 方式，元素在滚动时会在 `relative` 和 `fixed` 之间切换，常用于实现 **滚动吸顶/吸底** 效果（如导航栏、表头固定）。

### 020：absolute vs. fixed

🎯 **一句话总结**

**绝对定位**：跟"家长"走（相对定位父级）
**固定定位**：跟"屏幕"走（相对浏览器窗口）

| 特性           | `absolute` (绝对定位) | `fixed` (固定定位)       |
| -------------- | --------------------- | ------------------------ |
| **参照物**     | 最近的定位祖先元素    | 浏览器视窗（屏幕）       |
| **滚动影响**   | ❌ 不随页面滚动        | ✅ 永远固定在屏幕固定位置 |
| **脱离文档流** | ✅ 原位置不保留        | ✅ 原位置不保留           |
| **典型用途**   | 弹出层、下拉菜单      | 悬浮按钮、固定导航栏     |

💡 **记忆口诀**

绝对认爹，固定认屏，——绝对定位找父级，固定定位盯屏幕

### 021：如何实现滚动视差 ✔️

滚动视差（Parallax Scrolling）是一种让背景和前景以不同速度滚动的视觉效果，常用于增强页面的沉浸感。以下是几种实现方式：

1. CSS 固定背景：`background-attachment: fixed`（简单，兼容性好）。
2. CSS 3D 变换：`transform: translateZ()` 控制不同层滚动速度（性能优）。
3. JS 动态计算：监听 `scroll` 事件调整元素位置（灵活，适合复杂动画）。
4. 视差库：如 GSAP、Rellax.js（推荐，避免重复造轮子）

### 022：css 动画 vs. js 动画 ✔️

1. 实现方式
   - **CSS 动画**：通过 `@keyframes` 或 `transition` 实现，声明式写法，适合简单动画（如渐变、旋转）。
   - **JS 动画**：通过 `requestAnimationFrame` 或动画库（如 GSAP）动态计算，适合复杂交互（如物理引擎、精确控制）。
2. 性能

   - **CSS 动画**：浏览器优化更好（GPU 加速），适合高频渲染（如 `transform`、`opacity`）。

   - **JS 动画**：可控性强，但频繁操作 DOM 可能导致性能问题（需优化）。
3. 控制能力
   - **CSS 动画**：控制有限（如 `animation-play-state`），难以动态调整参数。
   - **JS 动画**：可实时修改动画（暂停、变速、回调），适合游戏、复杂交互。

4. 兼容性
   - **CSS 动画**：现代浏览器支持良好，但旧版 IE 兼容性差。
   - **JS 动画**：可通过 polyfill 兼容旧浏览器，灵活性更高。

CSS 动画性能更好，适合简单效果；JS 动画控制灵活，适合复杂交互。优化时优先用 CSS `transform/opacity` 触发 GPU 加速，复杂场景用 `requestAnimationFrame` 或 GSAP。





