### 001：什么是 BFC？如何触发 BFC？✔️

1. 基本概念：**B**lock **F**ormatting **C**ontext，块级格式化上下文，是 一块独立渲染区域，内部元素的布局不会影响外部元素。

2. 解决什么问题？

   - **清除浮动**（防止父元素高度塌陷）
   - **避免 margin 重叠**（相邻元素的 margin 不会合并）
   - **隔离布局**（内部元素不影响外部布局）

3. 满足以下条件，就可以创建BFC

   - `float: left/right`（非 `none`）
   - `position: absolute/fixed`
   - `display: inline-block / table-cell / flex / grid`
   - `overflow: hidden / auto / scroll`（非 `visible`）

**BFC 是一个独立布局空间，能解决浮动、margin 重叠等问题，通过 `float`、`position`、`display` 、`overflow` 等属性触发。**

### 002：px/em/rem ✔️

px、rem、em 都是表示长度或字体大小的单位，主要区别在于 **相对性** 和 **继承性**：

- `px`：固定单位，相对于 **显示器屏幕分辨率** 而言，值是固定的，指定多少就是多少。
- `em`：相对单位，相对于 **父元素** 字体大小，可被子元素继承。
  - em = 像素值 / 父元素字体大小
- `rem`：相对单位，相对于 **根元素** 字体大小，不会被子元素继承。
  - 根元素字体大小 = 设备宽度/设计稿宽度 * 100
  - rem = 设计稿值 / 100

### 003：谈一谈盒子模型

1. 组成：content - padding - border -margin
2. 标准盒子模型：box-sizing:content-box
3. IE盒子模型：box-sizing:border-box

### 004：CSS3有哪些新特性？

媒体查询/文本阴影/渐变/圆角/盒子阴影/过渡/动画/变形转换/弹性布局/网格布局/视口单位

### 005：link 与 @import 的区别？

`<link>`和`@import`都是用于在HTML或CSS中导入外部资源的方法，但它们有一些区别：

1. **用法和位置：**
   - `<link>`：`<link>`标签是HTML中的标签，用于在HTML文档中引入外部资源，如样式表、图标等。它通常位于`<head>`标签内，并使用`rel`属性指定资源的关系类型，如`stylesheet`表示样式表。
   - `@import`：`@import`是CSS中的规则，用于在CSS文件中导入外部样式表。它位于CSS文件的顶部，并在其他CSS规则之前使用。`@import`规则是以`@import`关键字开始的，并指定要导入的资源路径。
2. **加载行为：**
   - `<link>`：`<link>`标签在浏览器解析HTML文档时就会同时加载指定的资源，不会阻塞页面的渲染。它可以并行加载多个资源，提高加载效率。
   - `@import`：`@import`规则是在CSS文件加载时才会加载导入的资源。它会阻塞页面的渲染，直到该资源加载完成才会继续渲染。如果有多个`@import`规则，它们会按顺序加载。
3. **兼容性：**
   - `<link>`：`<link>`标签是HTML的一部分，几乎所有的浏览器都支持它。
   - `@import`：`@import`规则是CSS2引入的特性，它在一些旧版本的浏览器中可能不被完全支持。尤其在IE6-IE9中，对`@import`规则的支持存在一些限制。
4. **优先级：**
   - `<link>`：`<link>`标签中的样式表具有较高的优先级，可以覆盖其他样式规则。它们的加载顺序也会影响样式的优先级。
   - `@import`：`@import`规则的样式表优先级较低，它们会在其他样式规则之后加载，并且优先级较低的样式可能会被其他样式覆盖。

综上所述，`<link>`标签具有更广泛的兼容性，可以并行加载多个资源，并且在样式覆盖和优先级方面更灵活。相比之下，`@import`规则在加载行为和兼容性方面可能存在一些限制。因此，在实际开发中，优先选择使用`<link>`标签来引入外部样式表。

### 006：什么是外边距重叠？ ✔️

**定义**：相邻块级元素的垂直外边距会合并（重叠）的现象。

**重叠规则**：

1. 同号取大值（正正取最大，负负取最负）
2. 异号相加值（正负相加）

**典型场景**：

- 相邻兄弟元素
- 父元素与第一个/最后一个子元素（无边框/padding隔开时）
- 空块级元素（自身上下margin合并）

**面试技巧回答**

外边距重叠是指相邻块级元素的 **垂直边距** 会合并成一个边距。合并规则是：同号取绝对值大的，异号相加。常见于相邻元素、父子元素之间，可以通过创建BFC或添加边框/padding来避免。

### 007：`flex：0 1 auto` 是什么意思？✔️

`flex` 是 `flex-grow`、`flex-shrink`、`flex-basis` 的缩写：

- `flex-grow`：放大比例
  - 默认为0，表示如果存在剩余空间，也不放大，都为1时表示平均分配剩余空间；
- `flex-shrink`：缩小比例
  - 默认为1，即如果空间不足，该项目将等比缩小；
- `flex-basis`：用于设置项目占据的主轴空间（项目初始大小）
  - 默认为 auto，即项目大小由内容决定。
  - 设置为固定值表示项目占据的主轴大小等于固定值  。

> 延伸试题：
>
>  `flex:1` 是什么意思？
>
> `flex:1` 是 `flex-grow: 1`、`flex-shrink: 1`、`flex-basis: auto` 的缩写，表示元素会 **自动占据剩余空间**，并在空间不足时 **等比缩小**。

### 008：解释什么是浮动以及工作原理？

浮动是一种用于控制元素在页面布局中位置的属性。通过将元素浮动到文档流中的左侧或右侧，可以让其他元素环绕在其周围。

浮动的工作原理如下：

1. **浮动元素的定位：** 使用`float`属性可以将元素从正常的文档流中脱离出来，并移动到其容器的左侧或右侧。浮动元素会尽量向左或向右移动，直到碰到其容器的边缘或其他浮动元素。
2. **环绕效果：** 其他非浮动的元素会根据浮动元素的位置进行环绕布局。环绕效果使得文本和其他元素可以围绕在浮动元素的周围。

需要注意的是，浮动元素对父容器和其他兄弟元素的布局产生了一些影响：

- **父容器高度塌陷：** 当父容器中的所有子元素都是浮动元素时，父容器的高度将塌陷为0，因为浮动元素脱离了文档流，不会撑开父容器的高度。为了避免这种情况，可以在父容器上添加`overflow: auto`或`clearfix`来清除浮动。
- **兄弟元素的环绕布局：** 兄弟元素会围绕在浮动元素的周围进行布局。如果兄弟元素是块级元素，默认情况下会占据浮动元素旁边的空间，并向下移动。如果希望兄弟元素不环绕浮动元素，可以使用`clear`属性来清除浮动。

### 009：如何实现三栏布局

1. 绝对定位
2. 浮动
3. Flex → flex:1
4. Grid

### 010：如何实现元素居中？

1. 弹性盒模型；
2. 绝对定位 + margin:
3. 绝对定位 + 平移：transform：translate（-50%，-50%）;
4. line-height 和 height 保持一致（里面的元素必须是inline，否则不生效）；
5. 通过padding：（已知子元素宽高情况，但不推荐）； 

### 011：常见的 CSS 选择器有哪些？

| 选择器类型          | 示例                               | 说明                                       |
| :------------------ | :--------------------------------- | :----------------------------------------- |
| **元素选择器**      | `p`                                | 选择所有 `<p>` 元素                        |
| **类选择器**        | `.button`                          | 选择所有 `class="button"` 的元素           |
| **ID 选择器**       | `#header`                          | 选择 `id="header"` 的元素                  |
| **通用选择器**      | `*`                                | 选择页面中的所有元素                       |
| **后代选择器**      | `div p`                            | 选择 `div` 内的所有 `<p>` 元素             |
| **子元素选择器**    | `div > p`                          | 选择 `div` 的直接子元素 `<p>`              |
| **相邻兄弟选择器**  | `h1 + p`                           | 选择紧接在 `<h1>` 后面的 `<p>` 元素        |
| **通用兄弟选择器**  | `h1 ~ p`                           | 选择所有紧跟在 `<h1>` 后面的 `<p>` 元素    |
| **属性选择器**      | `a[href]`                          | 选择具有 `href` 属性的所有 `<a>` 元素      |
| **`:hover`**        | `a:hover`                          | 选择鼠标悬停时的 `<a>` 元素                |
| **`:first-child`**  | `p:first-child`                    | 选择父元素中的第一个 `<p>` 元素            |
| **`:nth-child(n)`** | `li:nth-child(odd)`                | 选择父元素中所有奇数位置的 `<li>` 元素     |
| **`::before`**      | `p::before { content: "Note: "; }` | 在每个 `<p>` 元素的前面插入 "Note: "       |
| **`::after`**       | `p::after { content: "."; }`       | 在每个 `<p>` 元素的后面插入一个句点        |
| **`:not()`**        | `p:not(.highlight)`                | 选择所有不具有 `highlight` 类的 `<p>` 元素 |

### 012：CSS 中可继承与不可继承属性有哪些？

**（1）继承属性**

- <u>字体</u> 系列属性：`font-family`、`font-weight`、`font-size`、`font-style`
- <u>文本</u> 系列属性：`text-indent`、`text-align`、`line-height`、`word-spacing`、`letter-spacing`、`text-transform`、`color`
- 元素可见性：`visibility`
- 列表布局属性：`list-style-type`、`ist-style-image` 等
- 光标属性：`cursor`

**（2）非继承属性**

- `display`
- 文本属性：`vertical-align`、`text-decoration`、`text-shadow`、`white-space`
- 盒子模型相关属性
- 背景属性
- 定位属性
- 轮廓样式属性
- ...

### 013：隐藏元素的方法有哪些？✔️

| 方法                  | 占据空间 | 触发重排/重绘 | 事件响应 | 动画支持 | 无障碍访问 |
| --------------------- | -------- | ------------- | -------- | -------- | ---------- |
| `display: none`       | ❌        | 重排 + 重绘   | ❌        | ❌        | ❌          |
| `visibility: hidden`  | ✔️        | 仅重绘        | ❌        | ✔️        | ❌          |
| `opacity: 0`          | ✔️        | 无            | ✔️        | ✔️        | ✔️          |
| `position: absolute`  | ❌        | 重排          | ❌        | ✔️        | ✔️          |
| `transform: scale(0)` | ✔️        | 无            | ✔️        | ✔️        | ✔️          |
| `height: 0`           | ❌        | 重排          | ❌        | ✔️        | ❌          |

### 014：伪元素和伪类的区别和作用？

- **伪类**：给**已有元素**加特效（如:hover变色）
- **伪元素**：在**元素内外**插内容（如::before加小图标）

### 015：CSS 优化和提高性能的方法有哪些？✔️

1. 合并压缩 CSS 文件，减少 HTTP 请求
2. 使用属性简写-组合值（如 margin: 10px 0 代替分写属性）
3. 简化选择器，避免深层嵌套（如 .nav-link 代替 div#header ul.nav li a）
4. 减少冗余代码，利用 CSS 继承机制（如 font-family 继承）
5. 避免频繁重绘和回流，用 transform 和 opacity 做动画
6. 使用雪碧图（CSS Sprite）合并小图标，减少请求
7. 采用字体图标（如 iconfont）替代图片，提升加载性能
8. 启用浏览器缓存，设置 Cache-Control 缓存 CSS 文件
9. 使用 CSS 预处理器（如 Sass/Less），提升开发效率并自动压缩代码
10. 触发硬件加速，通过 transform: translateZ(0) 提升动画性能
11. 按需加载 CSS，动态加载当前页面所需样式（如 import）
12. 用 PostCSS 自动优化，如添加前缀、删除未使用样式（PurgeCSS）

### 016：如何判断元素是否到达可视区域？

以图片显示为例：

![](./IMGS/iQ_view_area.png)

- `window.innerHeight` 是浏览器可视区的高度；

- `document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动过的距离；
- `imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）；
- 内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`

### 017：如何实现 Retina 屏 1px 像素边框？✔️

1. 使用 `transform: scale` 实现

   ```css
   .retina-border {
     position: relative;
   }
   
   .retina-border::after {
     content: '';
     position: absolute;
     left: 0;
     right: 0;
     bottom: 0;
     height: 1px; /* 边框的物理宽度 */
     background-color: black; /* 边框颜色 */
     transform: scaleY(0.5); /* 缩放到 0.5 */
     transform-origin: 0 0; /* 缩放起点 */
   }
   ```

2. 使用 `box-shadow` 模拟边框

   ```css
   .retina-border {
     position: relative;
     box-shadow: 0 1px 0 rgba(0, 0, 0, 0.5); /* 通过阴影模拟边框 */
   }
   ```

### 018：如何设置小于12px的字体？ ✔️

1. `zoom`：设置缩放比例
2. `transform:scale(xx)`

### 019：对 sticky 定位的理解？

`sticky` 是一种 **混合定位** 方式，元素在滚动时会在 `relative` 和 `fixed` 之间切换，常用于实现 **滚动吸顶/吸底** 效果（如导航栏、表头固定）。

### 020：absolute vs. fixed

🎯 **一句话总结**

**绝对定位**：跟"家长"走（相对定位父级）
**固定定位**：跟"屏幕"走（相对浏览器窗口）

| 特性           | `absolute` (绝对定位) | `fixed` (固定定位)       |
| -------------- | --------------------- | ------------------------ |
| **参照物**     | 最近的定位祖先元素    | 浏览器视窗（屏幕）       |
| **滚动影响**   | ❌ 不随页面滚动        | ✅ 永远固定在屏幕固定位置 |
| **脱离文档流** | ✅ 原位置不保留        | ✅ 原位置不保留           |
| **典型用途**   | 弹出层、下拉菜单      | 悬浮按钮、固定导航栏     |

💡 **记忆口诀**

绝对认爹，固定认屏，——绝对定位找父级，固定定位盯屏幕

### 021：如何实现滚动视差 ✔️

滚动视差（Parallax Scrolling）是一种让背景和前景以不同速度滚动的视觉效果，常用于增强页面的沉浸感。以下是几种实现方式：

1. CSS 固定背景：`background-attachment: fixed`（简单，兼容性好）。
2. CSS 3D 变换：`transform: translateZ()` 控制不同层滚动速度（性能优）。
3. JS 动态计算：监听 `scroll` 事件调整元素位置（灵活，适合复杂动画）。
4. 视差库：如 GSAP、Rellax.js（推荐，避免重复造轮子）

### 022：css 动画 vs. js 动画 ✔️

1. 实现方式
   - **CSS 动画**：通过 `@keyframes` 或 `transition` 实现，声明式写法，适合简单动画（如渐变、旋转）。
   - **JS 动画**：通过 `requestAnimationFrame` 或动画库（如 GSAP）动态计算，适合复杂交互（如物理引擎、精确控制）。
2. 性能

   - **CSS 动画**：浏览器优化更好（GPU 加速），适合高频渲染（如 `transform`、`opacity`）。

   - **JS 动画**：可控性强，但频繁操作 DOM 可能导致性能问题（需优化）。
3. 控制能力
   - **CSS 动画**：控制有限（如 `animation-play-state`），难以动态调整参数。
   - **JS 动画**：可实时修改动画（暂停、变速、回调），适合游戏、复杂交互。

4. 兼容性
   - **CSS 动画**：现代浏览器支持良好，但旧版 IE 兼容性差。
   - **JS 动画**：可通过 polyfill 兼容旧浏览器，灵活性更高。

CSS 动画性能更好，适合简单效果；JS 动画控制灵活，适合复杂交互。优化时优先用 CSS `transform/opacity` 触发 GPU 加速，复杂场景用 `requestAnimationFrame` 或 GSAP。

### 023：CSS 盒子模型，尺寸计算

如下代码，请问 `div1` 的 `offsetWidth` 是多大？

```html
<!-- 如下代码，请问 div1 的 offsetWidth 是多大？ -->
<style>
  #div1 {
    width: 100px;
    padding: 10px;
    border: 1px solid #ccc;
    margin: 10px;
  }
</style>

<div id="div1"></div>
```

答案：`offsetWidth` 是指 `元素内容 + 内间距 + 边框`的距离，不包括外间距，所以 `offsetWidth` 是 `122px

追问：如果想要让 `offsetWidth` 等于 `100px` ，还需要再增加一个什么属性？

答案：增加 `box-sizing: border-box;`

### 024：如何理解 `z-index` ？✔️

1. 用于控制元素的**堆叠顺序**（Z轴显示顺序），值越大越靠前
2. 只适用于**定位**的元素，需要设置 `position` 属性为 `relative`、`absolute`、`fixed` 或 `sticky`，否则 `z-index` 不生效
3. 比较规则：
   - **同级元素**：直接比较 `z-index` 值，大的覆盖小的
   - **父子元素**：子元素的 `z-index` 仅在父元素内有效，父元素的 `z-index` 决定整体层级
4. 默认值为 `auto`，支持负数（显示在背景下方）。

