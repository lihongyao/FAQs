https://www.cnblogs.com/crispyChicken/p/18719685

### 001：Webpack 和 Vite 的核心区别是什么？ ✔️

- Webpack：基于打包的思想，将所有模块打包成一个或多个 bundle 文件。它通过 loader 处理各种资源，通过 plugin 扩展功能。Webpack 的核心是依赖图，通过递归分析模块依赖关系，最终生成打包结果。
- Vite：基于浏览器原生 ES 模块的支持，利用现代浏览器的特性，实现按需加载。Vite 在开发环境下使用原生 ES 模块，避免了打包的过程，启动速度更快。生产环境下，Vite 使用 Rollup 进行打包。

**🤔 回答思路**

- Webpack 是传统的打包工具，适合复杂的项目，但启动和热更新速度较慢。

- Vite 利用现代浏览器的 ES 模块特性，开发环境下无需打包，启动速度极快，适合现代前端项目。

### 002：Webpack 的构建流程是怎样的？

- **初始化**：读取配置文件，初始化 Compiler 对象。
- **编译**：从入口文件开始，递归解析依赖，生成依赖图。
- **构建**：根据依赖图，调用 loader 处理模块，生成 chunk。
- **输出**：将 chunk 写入文件系统，生成最终的 bundle 文件。

**🤔 回答思路**

-  Webpack 的构建流程可以分为初始化、编译、构建和输出四个阶段。
- 通过 loader 处理不同类型的文件，通过 plugin 扩展功能。

### 003：Vite 的构建流程是怎样的？

- **开发环境**：Vite 启动一个开发服务器，利用浏览器的原生 ES 模块支持，按需加载模块。Vite 通过拦截浏览器请求，将模块转换为浏览器可识别的格式。
- **生产环境**：Vite 使用 Rollup 进行打包，生成优化的静态资源。

**🤔 回答思路**

- Vite 在开发环境下利用 ES 模块的特性，避免了打包的过程，启动速度更快。
- 生产环境下，Vite 使用 Rollup 进行打包，生成优化的静态资源。

### 004：Webpack 的优化策略有哪些？

- **代码分割（Code Splitting）**：通过 `SplitChunksPlugin` 将代码拆分成多个 chunk，实现按需加载。
- **Tree Shaking**：通过 ES 模块的静态分析，移除未使用的代码。
- **缓存**：使用 `cache-loader` 或 `hard-source-webpack-plugin` 缓存构建结果，加快构建速度。
- **懒加载（Lazy Loading）**：通过动态导入（`import()`）实现懒加载，减少初始加载时间。
- **压缩代码**：使用 `TerserPlugin` 压缩 JavaScript 代码，使用 `CssMinimizerPlugin` 压缩 CSS 代码。

**🤔 回答思路**

- Webpack 的优化策略包括代码分割、Tree Shaking、缓存、懒加载和代码压缩等。
- 通过这些策略可以减少打包体积，提升构建速度和运行时性能。

### 005：Vite 的优化策略有哪些？

- **按需加载**：利用 ES 模块的特性，按需加载模块，减少初始加载时间。
- **预构建**：Vite 会预构建依赖（`node_modules` 中的模块），减少开发环境下的请求数量。
- **缓存**：Vite 会缓存预构建的依赖，加快后续启动速度。
- **生产环境优化**：Vite 使用 Rollup 进行打包，支持 Tree Shaking 和代码压缩。

**🤔 回答思路**

- Vite 的优化策略包括按需加载、预构建、缓存和生产环境优化等。
- 通过这些策略可以提升开发体验和构建速度。

### 006：Webpack 和 Vite 的热更新（HMR）机制有何不同？

- **Webpack**：Webpack 的热更新机制是通过 `HotModuleReplacementPlugin` 实现的。Webpack 会监听文件变化，重新编译变化的模块，并通过 WebSocket 将更新推送到浏览器。
- **Vite**：Vite 的热更新机制是基于 ES 模块的特性。Vite 会监听文件变化，并通过浏览器原生的模块系统实现热更新，更新速度更快。

**🤔 回答思路**

- Webpack 的热更新是通过插件和 WebSocket 实现的，更新速度较慢。
- Vite 的热更新是基于浏览器原生的 ES 模块系统，更新速度更快。

### 007：如何选择 Webpack 和 Vite？

- **Webpack**：适合复杂的项目，尤其是需要兼容旧浏览器的项目。Webpack 的生态丰富，插件和 loader 众多，适合需要高度定制的项目。
- **Vite**：适合现代前端项目，尤其是使用 Vue 3、React 等现代框架的项目。Vite 的开发体验更好，启动和热更新速度更快。

**🤔 回答思路**

- 选择 Webpack 还是 Vite 取决于项目需求和团队技术栈。
- 如果需要兼容旧浏览器或需要高度定制，可以选择 Webpack。
- 如果是现代前端项目，追求开发体验和构建速度，可以选择 Vite。

### 008：Webpack 的 loader 和 plugin 的区别是什么？

- **loader**：用于处理模块的转换，例如将 TypeScript 转换为 JavaScript，将 SCSS 转换为 CSS。loader 是链式调用的，每个 loader 处理完模块后，会将结果传递给下一个 loader。
- **plugin**：用于扩展 Webpack 的功能，例如打包优化、资源管理、环境变量注入等。plugin 可以在 Webpack 的构建生命周期中插入自定义逻辑。

**🤔 回答思路**

- loader 用于处理模块的转换，plugin 用于扩展 Webpack 的功能。
- loader 是链式调用的，plugin 可以在构建生命周期的不同阶段插入自定义逻辑。

### 009：Vite 的插件机制是怎样的？

- Vite 的插件机制是基于 Rollup 的插件系统。Vite 的插件可以在开发环境和生产环境中使用，用于扩展 Vite 的功能。
- Vite 的插件可以拦截请求、修改模块、注入环境变量等。

**🤔 回答思路**

- Vite 的插件机制是基于 Rollup 的插件系统，可以在开发和生产环境中使用。
- 插件可以拦截请求、修改模块、注入环境变量等。

### 010：如何优化 Webpack 的构建速度？

- **减少构建范围**：通过 `exclude` 和 `include` 配置，减少不必要的文件处理。
- **多线程构建**：使用 `thread-loader` 或 `HappyPack` 开启多线程构建。
- **缓存**：使用 `cache-loader` 或 `hard-source-webpack-plugin` 缓存构建结果。
- **DLL 插件**：使用 `DllPlugin` 和 `DllReferencePlugin` 预构建不常变化的依赖。

**🤔 回答思路**

- 通过减少构建范围、多线程构建、缓存和使用 DLL 插件等方式，可以优化 Webpack 的构建速度。

### 011：webpack 性能优化 ✔️

通过减少构建范围、多线程构建、缓存和使用 DLL 插件等方式，可以优化 Webpack 的构建速度。

Webpack性能优化从两个方向来考虑，优化打包速度和优化打包文件大小：

1. 优化打包速度

   - 使用最新 Webpack 版本。
   - 分环境打包，避免加载多余插件。
   - 启用多线程 `thread-loader` 并行处理。
   - 缩小构建目标：
     - `exclude/include` 限定 loader 范围。
     - `resolve.alias` 路径别名。
     - `resolve.modules` 指定第三方模块路径。
     - `resolve.extensions` 减少后缀尝试。
     - `noParse` 忽略无需解析的库。
   - 利用缓存提升二次构建速度
     - `babel-loader` 开启 `cacheDirectory`。
     - `terser-webpack-plugin` 开启缓存。
     - 使用 `cache-loader`。
     - 开启文件系统缓存，提升二次构建速度（Webpack 5 默认开启）。
   - 预编译：预先编译资源模块。
   - 模块合并，合并小型模块较少请求次数（Webpack 5 默认开启）。
2. 优化打包体积

   - `TerserPlugin` 压缩 JS/CSS。
   - `SplitChunksPlugin` 提取公共代码。
   - Tree Shaking （Webpack 5 默认开启）
   - 代码分割：`Code Splitting` 按需加载（`import`）。
   - `@babel/preset-env` 设置 `useBuiltIns: 'usage'`。
   - 配置 `Asset Modules` 的 `maxSize`，将部分资源转为 base64，减少 HTTP 请求。

### 012：模块化 ✔️

涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

**模块化的优势：**

1. 解决命名冲突。
2. 提高代码的复用性和可维护性。

**模块化的实现方式：**

1. **IIFE（立即执行函数）**
   - 通过函数作用域解决命名冲突和污染全局作用域的问题。
   - **特点**：简单易用，适合小型项目。
2. **CommonJS**
   - Node.js 的模块化方案，支持同步加载和值拷贝。
   - **特点**：适合服务器端，模块加载是同步的。
3. **AMD（Asynchronous Module Definition）**
   - 异步模块定义，适用于浏览器环境。
   - **特点**：支持异步加载，适合大型应用。
4. **CMD（Common Module Definition）**
   - 类似 AMD，强调按需加载和延迟执行。
   - **特点**：更灵活，适合复杂场景。
5. **UMD（Universal Module Definition）**
   - 兼容 CommonJS、AMD 和 CMD。
   - **特点**：通用性强，适合多种环境。
6. **ESM（ECMAScript Modules）**
   - 原生模块化方案，支持异步导入和地址拷贝。
   - **特点**：现代标准，浏览器和 Node.js 均支持。

### 013：打包生成的文件名里那串数字或字母是什么？有何作用？✔️

是一串Hash 值，主要是为了 **解决浏览器缓存问题**。

这串 Hash 值是根据文件内容生成的，内容变则 Hash 变，能精准控制缓存，避免用户看到旧版本。

### 014：git fetch vs. git pull ✔️

- `git fetch` 只下载不自动合并，安全。
- `git pull` 下载并自动合并，= fetch + merge。

### 015：git stash pop vs. git stash apply

这两条指令都是用于恢复暂存的，区别在于：

- `git stash pop` 恢复后删除暂存。
- `git stash apply` 会保留暂存记录。

