### 001：webpack 和 rollup的区别？

1. 打包策略
   - Rollup的主要目标是生成更小、更精简的代码包。它通过静态分析和Tree Shaking等技术，将代码模块按需打包，消除未使用的代码，以减小最终生成的包的体积。
   - Webpack则更注重于处理复杂的应用场景，提供了更丰富的功能和插件生态系统。它可以处理各种类型的资源（如JavaScript、CSS、图片等），支持代码拆分、按需加载、动态导入等特性，以及更复杂的配置选项。
2. 静态和动态分析
   - Rollup在打包过程中使用静态分析，即在编译时就确定模块的依赖关系。这样可以更好地进行Tree Shaking，去除未使用的代码，生成更小的包。
   - Webpack采用动态分析，即在运行时根据模块加载的情况来确定依赖关系。这使得Webpack可以处理动态导入和代码拆分等复杂场景。
3. 生态系统和插件支持
   - Webpack 拥有庞大的插件生态系统，提供了丰富的插件和加载器，可以处理各种资源类型，以及提供了许多扩展功能（如热模块替换、代码分割等）。
   - Rollup的插件生态系统相对较小，但也提供了一些常用的插件和功能。
4. 使用场景
   - Rollup适合构建JavaScript库和组件，以及需要生成更小包体积的应用程序。
   - Webpack适合构建复杂的应用程序，处理多种类型的资源，具有更强大的功能和灵活的配置选项。

### 002：webpack 性能优化

Webpack性能优化从两个方向来考虑，优化打包速度和优化打包文件大小：

1. 优化打包速度

   - 使用最新版本。

   - 分环境打包，避免加载多余的插件。
   - 启用多线程（*thread-loader*）
   - 缩小构建目标。
     - exclude/include（*确定loader 规则范围*）
     - resolve.alias 路径别名
     - resolve.modules 指明第三方模块的绝对路径（减少不必要的查找）
     - resolve.extensions 尽可能减少后缀尝试的可能性
     - noParse 对完全不需要解析的库进行忽略·
   - 充分利用缓存提升二次构建速度
     - babel-loader 开启缓存
     - terser-webpack-plugin 开启缓存
     - cache-loader
   - 预先编译资源模块。

2. 优化打包体积

   - 代码压缩
   - 提取页面公共资源

   - Tree Shaking
   - 拆分代码（Code Spliting）减少main.js包的体积
   - @babel/preset-env开启按需加载（*useBuiltIns:usage*）
   - 使用Asset Modules时配置maxSize，将部分资源转成base64，减少http请求。

### 003：模块化 ⭐️

涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什 么特点？

模块化带来的好处：

1. 解决命名冲突
2. 提高代码的复用性和可维护性

实现方式：

1. IIFE-立即执行函数：在早期，使用立即执行函数实现模块化是常见的手段， 通过函数作用域解决了命名冲突 、污染全局作用域的问题
2. CommonJS：CommonJS 最早是 Node 在使用，支持同步/动态导入/值拷贝
3. AMD：异步·浏览器
4. CMD：类似AMD，强调按需加载和延迟执行
5. UMD：兼容CommonJS/AMD/CMD
6. ESM：原生实现的模块化方案，支持异步导入/地址拷贝